\chapter{Software Description}
Development on \SaltProc to enable use with \OpenMC consitutes a major portion
of this thesis. In this chapter, I will provide a high level overview
of my development process.\footnote{The release notes
contain more details for those interested} I will also provide an updated
description of the code structure using the new API. 

\section{SaltProc development history}%
\label{sub:saltproc-hisory}

\SaltProc\cite{rykhlevskii_saltproc_2018} is an open source Python package that
simulates on-line reprocessing via a batch-wise approach\footnote{Material is
moved to or from the core at specific time intervals} in liquid-fueled
\Gls{msr}s. More precisely, \SaltProc manages material flows and separation
processes on nuclides in the fuel. \SaltProc relies on external codes to simulate
fuel depletion.

The first version of \SaltProc (v0.1) was a simple Python 2.7 package that used
\SerpentTWO for the fuel depletion simulations. A single Python file contained
all functions; separation processes applied to materials used an implicit 100\%
extraction efficiency at hardcoded cycle times\cite{rykhlevskii_advanced_2018}.
The structure of \SaltProc v0.1 did not lend itsef easily to development of more
sophisticated treatments of reprocessing. This led to the release of \SaltProc
v0.2, in which the entire codebase was refactored into an object oriented
context in Python 3. The addition of new functionality in the \verb.Process.
classes enabled more sophisticated treatment of online reprocessing using user
defined extraction efficiencies and removed the cycle time functionality\cite{rykhlevskii_fuel_2020}.

\SaltProc v0.3 saw the implementation of processes for gas sparging and
separation to more accurately simulate the \gls{msbr}, as well as additional
refactoring to better follow OOP concepts.

While v0.2 and v0.3 saw most of \SaltProc refactored for OOP, before I could
implement \OpenMC support, I needed to resolve the following issues:
\begin{enumerate}
    \item Relocate several functions to have better separation of concerns
    \item Overhaul the \SaltProc input file format giving users more control over their simulations
    \item Generalize docstrings\footnote{Since \SaltProc was initally written as a script wrapped around Serpent2, many of the docstrings explicitly referenced Serpent2.}
    \item Improve function and variable names
\end{enumerate}
I implemented these changes as part of the 0.4.0 release. The changes in that
release changed the API, making 0.4.0 incompatible with previous verions of \SaltProc.

\SaltProc v0.5.0 added full support for \OpenMC, overhauled the test suite, and included additional API changes.

% consider talking about automation?

\section{OpenMC}%
\label{sub:openmc}

OpenMC \cite{romano_openmc_2015} is an open source Monte Carlo particle
transport code. The \Gls{crpg} at \Gls{mit} started developing OpenMC back in
2011 with a focus on scalability for exascale computing. Since that time,
developers new and old contributed features (cite?) and fixes to the tool
expanding its scope and use cases. Notable features of OpenMC (as of version
0.13.1) are as follows \cite{homepage_openmc_2022}:
\begin{itemize}
    \item Support for fixed source, $k$-eigenvalue, and subcritical neutron multiplication cacluclations.
    \item Support for \Gls{csg} and \Gls{cad} geometry.
    \item Support for both continuous and multigroup transport calculations.
    \item Support for parallel execution via MPI and OpenMP.
    \item Geometry visualization through the Python API.
    \item Transport-coupled and transport-independent depletion
\end{itemize}

\section{SaltProc v0.5.0}
\label{sec:saltproc-detail}

\subsection{Feeds and Separations}
\label{sub:feeds-separations}
\SaltProc models separations and feeds using three different data structures:


\paragraph{Material flows}
    A material flow represents a material with a given
    volume, density, and temperature, and nuclide composition.
    It can also include information such as void fraction. \verb.Materialflow.
    objects contain the prior mentioned quantities as attributes, as well as
    methods to perform the following:
    \begin{itemize}
        \item Add two \verb.Materialflow. objects together
        \item Multiply a \verb.Materialflow. object by a constant
    \end{itemize}
    \verb.Materialflow. objects are used to store information about materials
    in reprocessing as well as materials being fed into the system.

\paragraph{Processes}
    A process is an abstraction of chemical separation, extraction, or some
    other removal. Two processes commonly used in \Gls{msr}s include
    extracting metals using gas sparging and filtering. In \SaltProc,
    \verb.Process. objects contain data and functions to perform their
    associated processing task. At a minimum, a \verb.Process. object includes
    the following
    \begin{itemize}
        \item A mass flowrate, $\dot{m}$, that specifies the mass of fuel salt a process can operate on per unit time
        \item An extraction efficiency, $\epsilon$, for target element(s). This can be a constant value or a function.
        \item A method to apply the process on a \verb.Materialflow. object. 
    \end{itemize}

\paragraph{Graphs}
    A graph is a mathematical object that connects {\it nodes}\footnote{the
    terms verices and points are also used} with {\it edges}. More formally,
    a graph is a pair of sets, $(V, E)$, where
    \begin{itemize}
        \item $V$ is a set whose elements are called nodes
        \item $E$ is a set whose elements are pairs of elements in $V$
    \end{itemize}
    A directed graph is a graph where the elements are ordered pairs of elements
    in $V$. This gives the edges a direction. \SaltProc uses directed graphs to
    model the order and path in which processes operate on materials.
        
Processes and feesd are defined in one JSON input file, and the graph linking
processes is  defind in a DOT file. The process graph must be directed and
acyclic in order to work with \SaltProc v0.5.0. At runtime, \SaltProc reads this
input file to create \verb.Process. objects for each item in the file. Every
process file must have at lest a \verb.core_outlet. and \verb.core_inlet.
Process.

\subsection{Material reprocessing}
Recall that \SaltProc uses a {\it batchwise} reprocessing scheme.

Let $\mathbf{n}(t)^{j}$ denote the nuclide mass vector for depletable material
$j$ as function of time. For each depletable material $j$, the depletion solver numerically
integrates the equation

\begin{equation}
    \frac{d\mathbf{n}^{j}(t)}{dt} = \mathbf{A}(\mathbf{n}^{j}(t), t)
\end{equation}

from time $i$ to time $i+1$ to get $\mathbf{n}^{j}(i+1)$, where $A$ is the
depletion matrix. The specific details of integration are alredy covered in
numerous other works (cite some here). This is sequence is called a {\bf depletion
step}.

Now, let the mass and volume of depletable material $j$ be
$m^{j}$ and $V^{j}$ respectively. Let the mass flowrate of process $p$ be
$\dot{m}_{p}$. At the end of each depletion step, \SaltProc constructs process
paths from the process graph defined in the DOT file, and sequentially applies
each proceess $p$ in each path $r$ to the relevant materials to obtain thru
and waste streams for each material. \SaltProc tracks the mass and nuclide vector for both thru and waste streams. For thru
streams, \SaltProc also tracks the volume and mass flowrate. For every node
$p\in[0,l]$ where $0$ represents the core outlet and $l$ represents the core
inlet, in the path $r$, for the thru streams we have

% still need burnup, temp, density, void frac
\begin{equation}
    \mathbf{n}^{j}_{\text{thru, }p,r} = \mathbf{n}^{j}_{\text{thru, }p-1,r} (1 - \mathbf{\epsilon}^{j}_{p,r})
\end{equation}
\begin{equation}
    m^{j}_{\text{thru, } p,r} = \alpha_{p} m^{j}_{\text{thru, }p-1,r} - m^{j}_{\text{waste, }p,r}
\end{equation}
\begin{equation}
    V^{j}_{\text{thru, }p,r} = \alpha_{p}V^{j}_{\text{thru, }p-1,r}
\end{equation}
where 
\begin{equation}
    \alpha_{p,r} = \frac{\dot{m}_{p,r}}{\dot{m}_{\text{outlet}}}
\end{equation}
and the inital conditions are 
\begin{equation}
    \mathbf{n}^{j}_{\text{thru, }0,r} = \mathbf{n}^{j}(i+1)
\end{equation}
\begin{equation}
    m^{j}_{\text{thru, }0,r} = \rho^{j}(i+1)V^{j}(i+1)
\end{equation}
\begin{equation}
    V^{j}_{\text{thru, }0,r} = V^{j}(i+1)
\end{equation}
Similarly, for the waste streams, we have
\begin{equation}
    \mathbf{n}^{j}_{\text{waste, }p,r} = \mathbf{n}^{j}_{\text{thru, }p-1,r} \cdot \mathbf{\epsilon}^{j}_{p,r}
\end{equation}
\begin{equation}
    m^{j}_{\text{waste, }p,r} = \alpha_{p,r} m^{j}_{\text{thru, }p-1,r} \langle\mathbf{1},\mathbf{n}^{j}_{\text{waste, }p,r}\rangle
\end{equation}
\SaltProc does not currently track the volume and mass flowrate of waste streams.

After the recursive computation, \SaltProc sums thru and waste streams over all
paths to get the total thru stream at the inlet, and the total waste stream at
the inlet which represents all material removed during reprocessing.
\begin{equation}
    \mathbf{n}^{j}_{\text{thru, inlet, net}} = \frac{\sum_{r} m^{j}_{\text{thru, inlet, }r} \mathbf{n}^{j}_{\text{thru, inlet, }r}}{\sum_{r} m^{j}_{\text{thru, inlet, }r}}
\end{equation}
\begin{equation}
    \mathbf{n}^{j}_{\text{waste, inlet, net}} = \frac{\sum_{r} m^{j}_{\text{waste, inlet, }r} \mathbf{n}^{j}_{\text{waste, inlet, }r}}{m^{j}_{\text{waste, inlet, }r}}
\end{equation}

Before running the next depletion step, for any material that has an associated
feed material defined, \SaltProc will add an amount of the feed material
equivalent to the removed mass so that the mass of fuel salt undergoing depletion
remains constant.
For feed $j'$ corresponding to material $j$, we have
\begin{equation}
    \mathbf{n}^{j}_\text{filled} = \frac{m^{j}_{\text{thru, }l}\mathbf{n}^{j}_{\text{thru, inlet, net}} +  m^{j}_{\text{removed}}\mathbf{n}^{j'}}{m^{j}_{\text{thru,}0}}
\end{equation}

where 
\begin{equation}
    m^{j}_{\text{removed}} = m^{j}_{\text{thru,}0} - m^{j}_{\text{thru, } l}
\end{equation}
