\chapter{Software Description}
Development on \SaltProc to enable use with \OpenMC consitutes a major portion
of this thesis. In this chapter, I will provide a high level overview
of my development process.\footnote{The release notes
contain more details for those interested} I will also provide an updated
description of the code structure using the new API. 

\section{SaltProc development history}%
\label{sub:saltproc-hisory}

\SaltProc\cite{rykhlevskii_saltproc_2018} is an open source Python package that
simulates on-line reprocessing via a batch-wise approach\footnote{Material is
moved to or from the core at specific time intervals} in liquid-fueled
\Gls{msr}s. More precisely, \SaltProc manages material flows and separation
processes on nuclides in the fuel. \SaltProc relies on external codes to simulate
fuel depletion.

The first version of \SaltProc (v0.1) was a simple Python 2.7 package that used
\SerpentTWO for the fuel depletion simulations. A single Python file contained
all functions; separation processes applie dto  used an implicit 100\%
efficiency \cite{rykhlevskii_advanced_2018}. The structure of \SaltProc v0.1 did
not lend itsef easily to development of more sophisticated treatments of
reprocessing. This led to the release of \SaltProc v0.2, in which the entire
codebase was refactored into an object oriented context in Python 3. The
addition of new functionality in the \verb.Process. classes enabled more
sophisticated treatment of online reprocessing \cite{rykhlevskii_fuel_2020} 

\SaltProc v0.3 saw the implementation of processes for gas sparging and
separation to more accurately simulate the \gls{msbr}, as well as additional
refactoring to better follow OOP concepts.

While v0.2 and v0.3 saw most of \SaltProc refactored for OOP, before I could
implement \OpenMC support, I needed to resolve the following issues:
\begin{enumerate}
    \item Relocate several functions to have better separation of concerns
    \item Overhaul the \SaltProc input file format giving users more control over their simulations
    \item Generalize docstrings\footnote{Since \SaltProc was initally written as a script wrapped around Serpent2, many of the docstrings explicitly referenced Serpent2.}
    \item Improve function and variable names
\end{enumerate}
I implemented these changes as part of the 0.4.0 release. The changes in that
release changed the API, making 0.4.0 incompatible with previous verions of \SaltProc.

\SaltProc v0.5.0 added full support for \OpenMC, overhauled the test suite, and included additional API changes.

% consider talking about automation?

\section{OpenMC}%
\label{sub:openmc}

OpenMC \cite{romano_jpenmc_2015} is an open source Monte Carlo particle
transport code. The \Gls{crpg} at \Gls{mit} started developing OpenMC back in
2011 with a focus on scalability for exascale computing. Since that time,
developers new and old contributed features (cite?) and fixes to the tool
expanding its scope and use cases. Notable features of OpenMC (as of version
0.13.1) are as follows \cite{homepage_openmc_2022}:
\begin{itemize}
    \item Support for fixed source, $k$-eigenvalue, and subcritical neutron multiplication cacluclations.
    \item Support for \Gls{csg} and \Gls{cad} geometry.
    \item Support for both continuous and multigroup transport calculations.
    \item Support for parallel execution via MPI and OpenMP.
    \item Geometry visualization through the Python API.
    \item Transport-coupled and transport-independent depletion
\end{itemize}

\section{SaltProc v0.5.0}
\label{sec:saltproc-detail}

\subsection{Feeds and Separations}
\SaltProc models feeds and separations using Processes and graphs. Processes themselves are
defined in a JSON input file, and links between processes are defind in a DOT
file. The process graph must be directed and acyclic in order to work with
\SaltProc v0.5.0. At runtime, \SaltProc reads this input file to create
Process-class instances for each item in the file. Every process file must have
at lest a \verb.core_outlet. and \verb.core_inlet. Process. Processes have the following characteristics:
\begin{itemize}
    \item Capacity: \ldots
    \item Efficiency: Extraction efficitcy for specific elements as mass fraction
    \item 
\end{itemize}a mass flowrate that m

\subsection{Material reprocessing}
Recall that \SaltProc uses a {\it batchwise} reprocessing scheme.

Let $\mathbf{n}(t)^{j}$ denote the nuclide denisty vector for depletable material
$j$ as function of time. For each depletable material $j$, the depletion solver numerically
integrates the equation

\begin{equation}
    \frac{d\mathbf{n}^{j}(t)}{dt} = \mathbf{A}(\mathbf{n}^{j}(t), t)
\end{equation}

from time $i$ to time $i+1$ to get $\mathbf{n}^{j}(i+1)$, where $A$ is the
depletion matrix. The specific details of integration are alredy covered in
numerous other works (cite some here). This is sequence is called a {\bf depletion
step}.

Now, let the mass, volume, and mass flowrate of depletable material $j$ be
$m^{j}$, $V^{j}$, and $\dot{m}^{j}$. respectively. At the end of each depletion
step, SaltProc recursively applies processes $p$ in each path $r$ to the
relevant materials to obtain thru and waste streams for each material. SaltProc
tracks the mass and nuclide vector for both thru and waste streams. For thru
streams, SaltProc also tracks the volume and mass flowrate density vector. For
every node $p\in[0,l]$ where $0$ represents the core outlet and $l$ represents the core inlet, in the path $r$:

% still need burnup, temp, density, void frac
\begin{equation}
    \mathbf{n}^{j}_{\text{thru, }p,r} = \mathbf{n}^{j}_{\text{thru, }p-1,r} (1 - \mathbf{\epsilon}^{j}_{p,r})
\end{equation}
\begin{equation}
    m^{j}_{\text{thru, } p,r} = \alpha_{p} m^{j}_{\text{thru, }p-1,r} - m^{j}_{\text{waste, }p,r}
\end{equation}
\begin{equation}
    \dot{m}^{j}_{\text{thru, }p,r} = \alpha_{p}\dot{m}^{j}_{\text{thru, }p-1,r}
\end{equation}
\begin{equation}
    V^{j}_{\text{thru, }p,r} = \alpha_{p}V^{j}_{\text{thru, }p-1,r}
\end{equation}
where 
\begin{equation}
    \alpha_{p,r} = \frac{\dot{m}_{p,r}}{\dot{m}_{\text{outlet}}}
\end{equation}
\begin{equation}
    \mathbf{n}^{j}_{\text{thru, }0,r} = \mathbf{n}^{j}(i+1)
\end{equation}
\begin{equation}
    m^{j}_{\text{thru, }0,r} = \rho^{j}(i+1)V^{j}(i+1)
\end{equation}
\begin{equation}
    \dot{m}^{j}_{\text{thru, }0,r} = 0
\end{equation}
\begin{equation}
    V^{j}_{\text{thru, }0,r} = V^{j}(i+1)
\end{equation}
\begin{equation}
    \rho^{j}_{\text{thru, }0,r} = \rho^{j}(i+1)
\end{equation}
\begin{equation}
    b^{j}_{\text{thru, }0,r} = b^{j}(i+1)
\end{equation}

waste streams
\begin{equation}
    \mathbf{n}^{j}_{\text{waste, }p,r} = \mathbf{n}^{j}_{\text{thru, }p-1,r} \cdot \mathbf{\epsilon}^{j}_{p,r}
\end{equation}
\begin{equation}
    m^{j}_{\text{waste, }p,r} = \alpha_{p,r} \langle\mathbf{1},\mathbf{n}^{j}_{\text{waste, }p,r}\rangle
\end{equation}
SaltProc does not currently track the volume and mass flowrate of waste streams.

After the recursive computation, SaltProc sums thru and waste streams over all
paths to get the total thru stream at the inlet, and the total waste stream at
the inlet which represents all material removed during reprocessing.
\begin{equation}
    \mathbf{n}^{j}_{\text{thru, inlet, net}} = \sum_{r} \mathbf{n}^{j}_{\text{thru, inlet, }r}
\end{equation}
\begin{equation}
    \mathbf{n}^{j}_{\text{waste, inlet, net}} = \sum_{r} \mathbf{n}^{j}_{\text{waste, inlet, }r}
\end{equation}
